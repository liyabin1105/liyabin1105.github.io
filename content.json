{"meta":{"title":"李亚彬","subtitle":null,"description":"剑指所向，永不止步","author":"李亚彬","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Android Studio 3.0新功能特性和旧项目适配","slug":"Android Studio 3.0新功能特性和旧项目适配","date":"2017-11-03T06:55:59.000Z","updated":"2017-11-03T06:59:23.000Z","comments":true,"path":"2017/11/03/Android Studio 3.0新功能特性和旧项目适配/","link":"","permalink":"http://yoursite.com/2017/11/03/Android Studio 3.0新功能特性和旧项目适配/","excerpt":"官方更新说明https://developer.android.google.cn/studio/releases/index.html","text":"官方更新说明https://developer.android.google.cn/studio/releases/index.html gradle.properties12#新的dex编译器android.enableD8 = true build.gradle productFlavors 要求每个flavor都有配置一个dimension属性 12345demo &#123; dimension &quot;DimenA&quot; applicationId &quot;com.stone.myapplication.pro&quot; ...&#125; 这些dimension要配置在一个地方，一般放在defaultConfig中： 1234defaultConfig &#123; ... flavorDimensions &quot;DimenA&quot;, &quot;DimenB&quot;&#125; applicationVariants中的变化3.0前可以改变apk的输出路径和名字： 12345applicationVariants.all &#123; variant -&gt; variant.outputs.each &#123; output -&gt; output.outputFile = ... &#125;&#125; 3.0中，outputFile只有get方法，没有set方法了，所以不能通过这种方式设置 可以通过如下方式，设置输出apk的名字： 12345applicationVariants.all &#123; variant -&gt; variant.outputs.all &#123; outputFileName = &quot;v$&#123;variant.versionName&#125;_$&#123;variant.flavorName&#125;&#125;.apk&quot; &#125;&#125; 关于variant.outputs.each 要说的一点是：该迭代器，访问的对象需要在构建之前就已经是存在的。测试时发现如果在each内操作一个File对象，其对应的文件必须事先存在，才能操作；且在构建任务一开始运行时就被执行了。 旧项目适配","categories":[],"tags":[]},{"title":"RxJava 学习笔记","slug":"Hexo-搭建成功","date":"2017-10-30T07:01:22.000Z","updated":"2017-11-03T07:02:08.000Z","comments":true,"path":"2017/10/30/Hexo-搭建成功/","link":"","permalink":"http://yoursite.com/2017/10/30/Hexo-搭建成功/","excerpt":"基本概念Observable发射源，英文释义“可观察的”，在观察者模式中称为“被观察者”或“可观察对象”； Observer接收源，英文释义“观察者”，没错！就是观察者模式中的“观察者”，可接收Observable、Subject发射的数据；","text":"基本概念Observable发射源，英文释义“可观察的”，在观察者模式中称为“被观察者”或“可观察对象”； Observer接收源，英文释义“观察者”，没错！就是观察者模式中的“观察者”，可接收Observable、Subject发射的数据； SubjectSubject是一个比较特殊的对象，既可充当发射源，也可充当接收源，为避免初学者被混淆，本章将不对Subject做过多的解释和使用，重点放在Observable和Observer上，先把最基本方法的使用学会，后面再学其他的都不是什么问题； Subscriber“订阅者”，也是接收源，那它跟Observer有什么区别呢？Subscriber实现了Observer接口，比Observer多了一个最重要的方法unsubscribe( )，用来取消订阅，当你不再想接收数据了，可以调用unsubscribe( )方法停止接收，Observer 在 subscribe() 过程中,最终也会被转换成 Subscriber 对象，一般情况下，建议使用Subscriber作为接收源； SubscriptionObservable调用subscribe( )方法返回的对象，同样有unsubscribe( )方法，可以用来取消订阅事件； Action0RxJava中的一个接口，它只有一个无参call（）方法，且无返回值，同样还有Action1，Action2…Action9等，Action1封装了含有 1 个参的call（）方法，即call（T t），Action2封装了含有 2 个参数的call方法，即call（T1 t1，T2 t2），以此类推； Func0与Action0非常相似，也有call（）方法，但是它是有返回值的，同样也有Func0、Func1…Func9; 基本用法Observable的创建 使用create( ),最基本的创建方式： 12345678normalObservable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123;@Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123;subscriber.onNext(\"create1\"); //发射一个\"create1\"的Stringsubscriber.onNext(\"create2\"); //发射一个\"create2\"的Stringsubscriber.onCompleted();//发射完成,这种方法需要手动调用onCompleted，才会回调Observer的onCompleted方法&#125;&#125;); 使用just()创建一个Observable并自动调用onNext()发射数据： 1justObservable = Observable.just(\"just1\",\"just2\");//依次发送\"just1\"和\"just2\" 使用from()遍历集合，发送每个item： 123456789101112131415List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(\"from1\");list.add(\"from2\");list.add(\"from3\");fromObservable = Observable.from(list); //遍历list 每次发送一个/** 注意，just()方法也可以传list，但是发送的是整个list对象，而from（）发送的是list的一个item** /* 使用defer()，有观察者订阅时才创建Observable，并且为每个观察者创建一个新的Observable：deferObservable = Observable.defer(new Func0&lt;Observable&lt;String&gt;&gt;() &#123;@Override//注意此处的call方法没有Subscriber参数public Observable&lt;String&gt; call() &#123;return Observable.just(\"deferObservable\");&#125;&#125;); 使用interval(),创建一个按固定时间间隔发射整数序列的Observable，可用作定时器： 1intervalObservable = Observable.interval(1, TimeUnit.SECONDS);//每隔一秒发送一次 使用range(),创建一个发射特定整数序列的Observable，第一个参数为起始值，第二个为发送的个数，如果为0则不发送，负数则抛异常： 1rangeObservable = Observable.range(10, 5);//将发送整数10，11，12，13，14 使用timer(),创建一个Observable，它在一个给定的延迟后发射一个特殊的值，等同于Android中Handler的postDelay()方法： 1timeObservable = Observable.timer(3, TimeUnit.SECONDS); //3秒后发射一个值 使用repeat(),创建一个重复发射特定数据的Observable: 123456789101112131415repeatObservable = Observable.just(\"repeatObservable\").repeat(3);//重复发射3次### Observer的创建mObserver = new Observer&lt;String&gt;() &#123;@Overridepublic void onCompleted() &#123;LogUtil.log(\"onCompleted\");&#125;@Overridepublic void onError(Throwable e) &#123;&#125;@Overridepublic void onNext(String s) &#123;LogUtil.log(s);&#125;&#125;; Observable和Observer关联1justObservable.subscribe(mObserver); mObserver的onNext方法将会依次收到来自justObservable的数据”just1”、”just2”，另外，如果你不在意数据是否接收完或者是否出现错误，即不需要Observer的onCompleted()和onError()方法，可使用Action1，subscribe()支持将Action1作为参数传入,RxJava将会调用它的call方法来接收数据，代码如下： 123456justObservable.subscribe(new Action1&lt;String&gt;() &#123;@Overridepublic void call(String s) &#123;LogUtil.log(s);&#125;&#125;); 例子从数据库的用户表查找出所有用户数据123456789101112131415Observable.create(new Observable.OnSubscribe&lt;List&lt;User&gt;&gt;() &#123;@Overridepublic void call(Subscriber&lt;? super List&lt;User&gt;&gt; subscriber) &#123;List&lt;User&gt; userList = null;···//从数据库获取用户表数据并赋给userList···subscriber.onNext(userList);&#125;&#125;).subscribe(new Action1&lt;List&lt;User&gt;&gt;() &#123;@Overridepublic void call(List&lt;User&gt; users) &#123;//获取到用户信息列表&#125;&#125;); 只查询名字是“小明”的用户12345678910111213141516171819202122232425Observable.create(new Observable.OnSubscribe&lt;List&lt;User&gt;&gt;() &#123;@Overridepublic void call(Subscriber&lt;? super List&lt;User&gt;&gt; subscriber) &#123;List&lt;User&gt; userList = null;···//从数据库获取用户表数据并赋给userList···subscriber.onNext(userList);&#125;&#125;).flatMap(new Func1&lt;List&lt;User&gt;, Observable&lt;User&gt;&gt;() &#123;@Overridepublic Observable&lt;User&gt; call(List&lt;User&gt; users) &#123;return Observable.from(users);&#125;&#125;).filter(new Func1&lt;User, Boolean&gt;() &#123;@Overridepublic Boolean call(User user) &#123;return user.getName().equals(\"小明\");&#125;&#125;).subscribe(new Action1&lt;User&gt;() &#123;@Overridepublic void call(User user) &#123;//拿到谜之小明的数据&#125;&#125;); 改为查询小明爸爸的数据bash Observable.create(new Observable.OnSubscribe&lt;List&lt;User&gt;&gt;() { @Override public void call(Subscriber&lt;? super List&lt;User&gt;&gt; subscriber) { List&lt;User&gt; userList = null; ··· //从数据库获取用户表数据并赋给userList ··· subscriber.onNext(userList); } }).flatMap(new Func1&lt;List&lt;User&gt;, Observable&lt;User&gt;&gt;() { @Override public Observable&lt;User&gt; call(List&lt;User&gt; users) { return Observable.from(users); } }).filter(new Func1&lt;User, Boolean&gt;() { @Override public Boolean call(User user) { return user.getName().equals(&quot;小明&quot;); } }).map(new Func1&lt;User, User&gt;() { @Override public User call(User user) { //根据小明的数据user从数据库查找出小明的父亲user2 return user2; } }).subscribe(new Action1&lt;User&gt;() { @Override public void call(User user2) { //拿到谜之小明的爸爸的数据 } }); bash","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2017-10-30T06:14:35.000Z","updated":"2017-10-31T06:08:01.000Z","comments":true,"path":"2017/10/30/hello-world/","link":"","permalink":"http://yoursite.com/2017/10/30/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}