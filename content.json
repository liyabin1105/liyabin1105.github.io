{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"李亚彬","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Hexo 搭建成功","slug":"Hexo-搭建成功","date":"2017-10-30T07:01:22.000Z","updated":"2017-10-31T01:38:45.000Z","comments":true,"path":"2017/10/30/Hexo-搭建成功/","link":"","permalink":"http://yoursite.com/2017/10/30/Hexo-搭建成功/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2017-10-30T06:14:35.000Z","updated":"2017-10-30T06:14:35.000Z","comments":true,"path":"2017/10/30/hello-world/","link":"","permalink":"http://yoursite.com/2017/10/30/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"RxJava 学习笔记","slug":"RxJava学习","date":"2017-03-14T02:39:34.000Z","updated":"2017-10-31T01:38:55.000Z","comments":true,"path":"2017/03/14/RxJava学习/","link":"","permalink":"http://yoursite.com/2017/03/14/RxJava学习/","excerpt":"","text":"##基本概念 ####Observable发射源，英文释义“可观察的”，在观察者模式中称为“被观察者”或“可观察对象”； ####Observer接收源，英文释义“观察者”，没错！就是观察者模式中的“观察者”，可接收Observable、Subject发射的数据； ####SubjectSubject是一个比较特殊的对象，既可充当发射源，也可充当接收源，为避免初学者被混淆，本章将不对Subject做过多的解释和使用，重点放在Observable和Observer上，先把最基本方法的使用学会，后面再学其他的都不是什么问题； ####Subscriber“订阅者”，也是接收源，那它跟Observer有什么区别呢？Subscriber实现了Observer接口，比Observer多了一个最重要的方法unsubscribe( )，用来取消订阅，当你不再想接收数据了，可以调用unsubscribe( )方法停止接收，Observer 在 subscribe() 过程中,最终也会被转换成 Subscriber 对象，一般情况下，建议使用Subscriber作为接收源； ####SubscriptionObservable调用subscribe( )方法返回的对象，同样有unsubscribe( )方法，可以用来取消订阅事件； ####Action0RxJava中的一个接口，它只有一个无参call（）方法，且无返回值，同样还有Action1，Action2…Action9等，Action1封装了含有 1 个参的call（）方法，即call（T t），Action2封装了含有 2 个参数的call方法，即call（T1 t1，T2 t2），以此类推； ####Func0与Action0非常相似，也有call（）方法，但是它是有返回值的，同样也有Func0、Func1…Func9; ##基本用法 ###Observable的创建 使用create( ),最基本的创建方式： normalObservable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() { @Override public void call(Subscriber&lt;? super String&gt; subscriber) { subscriber.onNext(&quot;create1&quot;); //发射一个&quot;create1&quot;的String subscriber.onNext(&quot;create2&quot;); //发射一个&quot;create2&quot;的String subscriber.onCompleted();//发射完成,这种方法需要手动调用onCompleted，才会回调Observer的onCompleted方法 } }); 使用just()创建一个Observable并自动调用onNext()发射数据： justObservable = Observable.just(&quot;just1&quot;,&quot;just2&quot;);//依次发送&quot;just1&quot;和&quot;just2&quot; 使用from()遍历集合，发送每个item： List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;from1&quot;); list.add(&quot;from2&quot;); list.add(&quot;from3&quot;); fromObservable = Observable.from(list); //遍历list 每次发送一个 /** 注意，just()方法也可以传list，但是发送的是整个list对象，而from（）发送的是list的一个item** / 使用defer()，有观察者订阅时才创建Observable，并且为每个观察者创建一个新的Observable： deferObservable = Observable.defer(new Func0&lt;Observable&lt;String&gt;&gt;() { @Override //注意此处的call方法没有Subscriber参数 public Observable&lt;String&gt; call() { return Observable.just(&quot;deferObservable&quot;); } }); 使用interval(),创建一个按固定时间间隔发射整数序列的Observable，可用作定时器： intervalObservable = Observable.interval(1, TimeUnit.SECONDS);//每隔一秒发送一次 使用range(),创建一个发射特定整数序列的Observable，第一个参数为起始值，第二个为发送的个数，如果为0则不发送，负数则抛异常： rangeObservable = Observable.range(10, 5);//将发送整数10，11，12，13，14 使用timer(),创建一个Observable，它在一个给定的延迟后发射一个特殊的值，等同于Android中Handler的postDelay()方法： timeObservable = Observable.timer(3, TimeUnit.SECONDS); //3秒后发射一个值 使用repeat(),创建一个重复发射特定数据的Observable: repeatObservable = Observable.just(&quot;repeatObservable&quot;).repeat(3);//重复发射3次 ###Observer的创建 mObserver = new Observer&lt;String&gt;() { @Override public void onCompleted() { LogUtil.log(&quot;onCompleted&quot;); } @Override public void onError(Throwable e) { } @Override public void onNext(String s) { LogUtil.log(s); } }; ###Observable和Observer关联 justObservable.subscribe(mObserver);mObserver的onNext方法将会依次收到来自justObservable的数据”just1”、”just2”，另外，如果你不在意数据是否接收完或者是否出现错误，即不需要Observer的onCompleted()和onError()方法，可使用Action1，subscribe()支持将Action1作为参数传入,RxJava将会调用它的call方法来接收数据，代码如下： justObservable.subscribe(new Action1&lt;String&gt;() { @Override public void call(String s) { LogUtil.log(s); } }); ##例子 ####从数据库的用户表查找出所有用户数据 Observable.create(new Observable.OnSubscribe","categories":[],"tags":[]}]}